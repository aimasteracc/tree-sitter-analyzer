
"""
„Çµ„É≥„Éó„É´„Éï„Ç©„Éº„Éû„ÉÉ„Çø„ÉºÂÆüË£Ö‰æã

„Åì„ÅÆ„Éï„Ç°„Ç§„É´„ÅØ„ÄÅÊñ∞„Åó„ÅÑ„Éï„Ç©„Éº„Éû„ÉÉ„Çø„Éº„ÇíÂÆüË£Ö„Åô„ÇãÈöõ„ÅÆÂèÇËÄÉ„Å®„Åó„Å¶‰ΩøÁî®„Åß„Åç„Çã
ÂÆåÂÖ®„Å™„Çµ„É≥„Éó„É´ÂÆüË£Ö„Åß„Åô„ÄÇË§áÊï∞„ÅÆÂá∫ÂäõÂΩ¢Âºè„Çí„Çµ„Éù„Éº„Éà„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ
"""

from typing import Dict, List, Any, Optional
import json
import csv
import io
from abc import ABC, abstractmethod

from tree_sitter_analyzer.formatters.base import BaseFormatter
from tree_sitter_analyzer.models import (
    AnalysisResult, ModelFunction, ModelClass, ModelVariable, ModelImport
)


class EnhancedFormatter(BaseFormatter):
    """
    Êã°Âºµ„Éï„Ç©„Éº„Éû„ÉÉ„Çø„Éº„ÅÆ„Çµ„É≥„Éó„É´ÂÆüË£Ö
    
    Ë§áÊï∞„ÅÆÂá∫ÂäõÂΩ¢Âºè„Å®Ë©≥Á¥∞„Å™„Ç´„Çπ„Çø„Éû„Ç§„Ç∫„Ç™„Éó„Ç∑„Éß„É≥„Çí„Çµ„Éù„Éº„Éà„Åó„Åæ„Åô„ÄÇ
    """
    
    def __init__(self, format_type: str, **kwargs):
        """
        „Éï„Ç©„Éº„Éû„ÉÉ„Çø„Éº„ÅÆÂàùÊúüÂåñ
        
        Args:
            format_type: Âá∫ÂäõÂΩ¢Âºè ("table", "json", "csv", "markdown", "html")
            **kwargs: ËøΩÂä†„Ç™„Éó„Ç∑„Éß„É≥
        """
        super().__init__(format_type, **kwargs)
        
        # „Ç´„Çπ„Çø„Éû„Ç§„Ç∫„Ç™„Éó„Ç∑„Éß„É≥
        self.options = {
            "include_metadata": kwargs.get("include_metadata", True),
            "include_docstrings": kwargs.get("include_docstrings", True),
            "include_line_numbers": kwargs.get("include_line_numbers", True),
            "include_visibility": kwargs.get("include_visibility", True),
            "max_line_length": kwargs.get("max_line_length", 100),
            "indent_size": kwargs.get("indent_size", 2),
            "sort_by": kwargs.get("sort_by", "name"),  # name, line, type
            "group_by": kwargs.get("group_by", None),  # type, visibility, module
            "filter_by": kwargs.get("filter_by", {}),  # Êù°‰ª∂„Éï„Ç£„É´„Çø
            "custom_fields": kwargs.get("custom_fields", []),  # ËøΩÂä†„Éï„Ç£„Éº„É´„Éâ
        }
        
        # Áµ±Ë®àÊÉÖÂ†±
        self.stats = {
            "formatted_items": 0,
            "total_size": 0,
            "format_time": 0.0
        }
    
    def format_analysis_result(self, result: AnalysisResult) -> str:
        """
        Ëß£ÊûêÁµêÊûúÂÖ®‰Ωì„Çí„Éï„Ç©„Éº„Éû„ÉÉ„Éà
        
        Args:
            result: Ëß£ÊûêÁµêÊûú
            
        Returns:
            str: „Éï„Ç©„Éº„Éû„ÉÉ„ÉàÊ∏à„ÅøÊñáÂ≠óÂàó
        """
        import time
        start_time = time.time()
        
        try:
            if self.format_type == "table":
                output = self._format_table(result)
            elif self.format_type == "json":
                output = self._format_json(result)
            elif self.format_type == "csv":
                output = self._format_csv(result)
            elif self.format_type == "markdown":
                output = self._format_markdown(result)
            elif self.format_type == "html":
                output = self._format_html(result)
            elif self.format_type == "xml":
                output = self._format_xml(result)
            else:
                raise ValueError(f"Unsupported format type: {self.format_type}")
            
            # Áµ±Ë®àÊõ¥Êñ∞
            self.stats["formatted_items"] += 1
            self.stats["total_size"] += len(output)
            self.stats["format_time"] += time.time() - start_time
            
            return output
            
        except Exception as e:
            raise Exception(f"Formatting failed: {str(e)}")
    
    def _format_table(self, result: AnalysisResult) -> str:
        """„ÉÜ„Éº„Éñ„É´ÂΩ¢Âºè„Åß„ÅÆ„Éï„Ç©„Éº„Éû„ÉÉ„Éà"""
        lines = []
        
        # „Éò„ÉÉ„ÉÄ„ÉºÊÉÖÂ†±
        lines.append(f"üìÅ „Éï„Ç°„Ç§„É´: {result.file_path}")
        lines.append(f"üî§ Ë®ÄË™û: {result.language}")
        lines.append("=" * 80)
        
        # Èñ¢Êï∞„Çª„ÇØ„Ç∑„Éß„É≥
        if result.functions:
            lines.append("\nüîß Èñ¢Êï∞‰∏ÄË¶ß")
            lines.append("-" * 40)
            
            # „ÇΩ„Éº„Éà
            functions = self._sort_items(result.functions)
            
            # „ÉÜ„Éº„Éñ„É´„Éò„ÉÉ„ÉÄ„Éº
            headers = ["ÂêçÂâç", "ÂèØË¶ñÊÄß", "„Éë„É©„É°„Éº„Çø", "Êàª„ÇäÂÄ§", "Ë°åÁï™Âè∑"]
            if self.options["include_docstrings"]:
                headers.append("Ë™¨Êòé")
            
            # „Ç´„É©„É†ÂπÖ„ÅÆË®àÁÆó
            col_widths = self._calculate_column_widths(functions, headers)
            
            # „Éò„ÉÉ„ÉÄ„ÉºË°å
            header_line = " | ".join(h.ljust(w) for h, w in zip(headers, col_widths))
            lines.append(header_line)
            lines.append("-" * len(header_line))
            
            # „Éá„Éº„ÇøË°å
            for func in functions:
                if self._should_include_item(func):
                    row = self._format_function_row(func, col_widths)
                    lines.append(row)
        
        # „ÇØ„É©„Çπ„Çª„ÇØ„Ç∑„Éß„É≥
        if result.classes:
            lines.append("\nüì¶ „ÇØ„É©„Çπ‰∏ÄË¶ß")
            lines.append("-" * 40)
            
            classes = self._sort_items(result.classes)
            
            for cls in classes:
                if self._should_include_item(cls):
                    lines.append(self._format_class_summary(cls))
        
        # Â§âÊï∞„Çª„ÇØ„Ç∑„Éß„É≥
        if result.variables:
            lines.append("\nüìä Â§âÊï∞‰∏ÄË¶ß")
            lines.append("-" * 40)
            
            variables = self._sort_items(result.variables)
            
            for var in variables:
                if self._should_include_item(var):
                    lines.append(self._format_variable_summary(var))
        
        # „Ç§„É≥„Éù„Éº„Éà„Çª„ÇØ„Ç∑„Éß„É≥
        if result.imports:
            lines.append("\nüì• „Ç§„É≥„Éù„Éº„Éà‰∏ÄË¶ß")
            lines.append("-" * 40)
            
            for imp in result.imports:
                lines.append(self._format_import_summary(imp))
        
        # Áµ±Ë®àÊÉÖÂ†±
        if self.options["include_metadata"]:
            lines.append("\nüìà Áµ±Ë®àÊÉÖÂ†±")
            lines.append("-" * 40)
            lines.append(f"Èñ¢Êï∞Êï∞: {len(result.functions)}")
            lines.append(f"„ÇØ„É©„ÇπÊï∞: {len(result.classes)}")
            lines.append(f"Â§âÊï∞Êï∞: {len(result.variables)}")
            lines.append(f"„Ç§„É≥„Éù„Éº„ÉàÊï∞: {len(result.imports)}")
            
            if result.metadata:
                for key, value in result.metadata.items():
                    lines.append(f"{key}: {value}")
        
        return "\n".join(lines)
    
    def _format_json(self, result: AnalysisResult) -> str:
        """JSONÂΩ¢Âºè„Åß„ÅÆ„Éï„Ç©„Éº„Éû„ÉÉ„Éà"""
        data = {
            "file_path": result.file_path,
            "language": result.language,
            "summary": {
                "functions": len(result.functions),
                "classes": len(result.classes),
                "variables": len(result.variables),
                "imports": len(result.imports)
            }
        }
        
        # Ë©≥Á¥∞„Éá„Éº„Çø
        if result.functions:
            data["functions"] = [self._function_to_dict(f) for f in result.functions 
                               if self._should_include_item(f)]
        
        if result.classes:
            data["classes"] = [self._class_to_dict(c) for c in result.classes 
                             if self._should_include_item(c)]
        
        if result.variables:
            data["variables"] = [self._variable_to_dict(v) for v in result.variables 
                               if self._should_include_item(v)]
        
        if result.imports:
            data["imports"] = [self._import_to_dict(i) for i in result.imports]
        
        # „É°„Çø„Éá„Éº„Çø
        if self.options["include_metadata"] and result.metadata:
            data["metadata"] = result.metadata
        
        return json.dumps(data, indent=self.options["indent_size"], ensure_ascii=False)
    
    def _format_csv(self, result: AnalysisResult) -> str:
        """CSVÂΩ¢Âºè„Åß„ÅÆ„Éï„Ç©„Éº„Éû„ÉÉ„Éà"""
        output = io.StringIO()
        
        # Èñ¢Êï∞„ÅÆCSV
        if result.functions:
            writer = csv.writer(output)
            
            # „Éò„ÉÉ„ÉÄ„Éº
            headers = ["type", "name", "visibility", "parameters", "return_type", 
                      "start_line", "end_line", "is_method"]
            if self.options["include_docstrings"]:
                headers.append("docstring")
            
            writer.writerow(headers)
            
            # „Éá„Éº„Çø
            for func in result.functions:
                if self._should_include_item(func):
                    row = [
                        "function",
                        func.name,
                        func.visibility or "",
                        "; ".join(func.parameters) if func.parameters else "",
                        func.return_type or "",
                        func.start_line,
                        func.end_line,
                        func.is_method
                    ]
                    
                    if self.options["include_docstrings"]:
                        row.append(func.docstring or "")
                    
                    writer.writerow(row)
        
        # „ÇØ„É©„Çπ„ÅÆCSV
        if result.classes:
            for cls in result.classes:
                if self._should_include_item(cls):
                    row = [
                        "class",
                        cls.name,
                        cls.visibility or "",
                        "; ".join(cls.base_classes) if cls.base_classes else "",
                        "",  # return_type (N/A for classes)
                        cls.start_line,
                        cls.end_line,
                        False  # is_method (N/A for classes)
                    ]
                    
                    if self.options["include_docstrings"]:
                        row.append(cls.docstring or "")
                    
                    writer.writerow(row)
        
        return output.getvalue()
    
    def _format_markdown(self, result: AnalysisResult) -> str:
        """MarkdownÂΩ¢Âºè„Åß„ÅÆ„Éï„Ç©„Éº„Éû„ÉÉ„Éà"""
        lines = []
        
        # „Çø„Ç§„Éà„É´
        lines.append(f"# Ëß£ÊûêÁµêÊûú: {result.file_path}")
        lines.append(f"**Ë®ÄË™û**: {result.language}")
        lines.append("")
        
        # ÁõÆÊ¨°
        lines.append("## ÁõÆÊ¨°")
        if result.functions:
            lines.append("- [Èñ¢Êï∞‰∏ÄË¶ß](#Èñ¢Êï∞‰∏ÄË¶ß)")
        if result.classes:
            lines.append("- [„ÇØ„É©„Çπ‰∏ÄË¶ß](#„ÇØ„É©„Çπ‰∏ÄË¶ß)")
        if result.variables:
            lines.append("- [Â§âÊï∞‰∏ÄË¶ß](#Â§âÊï∞‰∏ÄË¶ß)")
        if result.imports:
            lines.append("- [„Ç§„É≥„Éù„Éº„Éà‰∏ÄË¶ß](#„Ç§„É≥„Éù„Éº„Éà‰∏ÄË¶ß)")
        lines.append("")
        
        # Èñ¢Êï∞„Çª„ÇØ„Ç∑„Éß„É≥
        if result.functions:
            lines.append("## Èñ¢Êï∞‰∏ÄË¶ß")
            lines.append("")
            
            functions = self._sort_items(result.functions)
            
            for func in functions:
                if self._should_include_item(func):
                    lines.extend(self._format_function_markdown(func))
                    lines.append("")
        
        # „ÇØ„É©„Çπ„Çª„ÇØ„Ç∑„Éß„É≥
        if result.classes:
            lines.append("## „ÇØ„É©„Çπ‰∏ÄË¶ß")
            lines.append("")
            
            classes = self._sort_items(result.classes)
            
            for cls in classes:
                if self._should_include_item(cls):
                    lines.extend(self._format_class_markdown(cls))
                    lines.append("")
        
        # Â§âÊï∞„Çª„ÇØ„Ç∑„Éß„É≥
        if result.variables:
            lines.append("## Â§âÊï∞‰∏ÄË¶ß")
            lines.append("")
            
            variables = self._sort_items(result.variables)
            
            lines.append("| ÂêçÂâç | Âûã | ÂèØË¶ñÊÄß | Ë°åÁï™Âè∑ |")
            lines.append("|------|----|---------|---------| ")
            
            for var in variables:
                if self._should_include_item(var):
                    lines.append(self._format_variable_markdown_row(var))
            
            lines.append("")
        
        # „Ç§„É≥„Éù„Éº„Éà„Çª„ÇØ„Ç∑„Éß„É≥
        if result.imports:
            lines.append("## „Ç§„É≥„Éù„Éº„Éà‰∏ÄË¶ß")
            lines.append("")
            
            for imp in result.imports:
                lines.append(f"- `{imp.module}`: {', '.join(imp.names) if imp.names else '*'}")
            
            lines.append("")
        
        return "\n".join(lines)
    
    def _format_html(self, result: AnalysisResult) -> str:
        """HTMLÂΩ¢Âºè„Åß„ÅÆ„Éï„Ç©„Éº„Éû„ÉÉ„Éà"""
        html_parts = []
        
        # HTML„Éò„ÉÉ„ÉÄ„Éº
        html_parts.append("""
<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ëß£ÊûêÁµêÊûú</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .header { background-color: #f5f5f5; padding: 10px; border-radius: 5px; }
        .section { margin: 20px 0; }
        .function, .class { border: 1px solid #ddd; margin: 10px 0; padding: 10px; border-radius: 5px; }
        .function-name, .class-name { font-weight: bold; color: #0066cc; }
        .visibility { color: #666; font-size: 0.9em; }
        .line-number { color: #999; font-size: 0.8em; }
        table { border-collapse: collapse; width: 100%; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #f2f2f2; }
        .docstring { font-style: italic; color: #666; margin-top: 5px; }
    </style>
</head>
<body>
        """)
        
        # „Éò„ÉÉ„ÉÄ„ÉºÊÉÖÂ†±
        html_parts.append(f"""
    <div class="header">
        <h1>Ëß£ÊûêÁµêÊûú: {result.file_path}</h1>
        <p><strong>Ë®ÄË™û:</strong> {result.language}</p>
        <p><strong>Áµ±Ë®à:</strong> Èñ¢Êï∞ {len(result.functions)}, „ÇØ„É©„Çπ {len(result.classes)}, Â§âÊï∞ {len(result.variables)}</p>
    </div>
        """)
        
        # Èñ¢Êï∞„Çª„ÇØ„Ç∑„Éß„É≥
        if result.functions:
            html_parts.append('<div class="section">')
            html_parts.append('<h2>Èñ¢Êï∞‰∏ÄË¶ß</h2>')
            
            functions = self._sort_items(result.functions)
            
            for func in functions:
                if self._should_include_item(func):
                    html_parts.append(self._format_function_html(func))
            
            html_parts.append('</div>')
        
        # „ÇØ„É©„Çπ„Çª„ÇØ„Ç∑„Éß„É≥
        if result.classes:
            html_parts.append('<div class="section">')
            html_parts.append('<h2>„ÇØ„É©„Çπ‰∏ÄË¶ß</h2>')
            
            classes = self._sort_items(result.classes)
            
            for cls in classes:
                if self._should_include_item(cls):
                    html_parts.append(self._format_class_html(cls))
            
            html_parts.append('</div>')
        
        # HTML„Éï„ÉÉ„Çø„Éº
        html_parts.append("""
</body>
</html>
        """)
        
        return "".join(html_parts)
    
    def _format_xml(self, result: AnalysisResult) -> str:
        """XMLÂΩ¢Âºè„Åß„ÅÆ„Éï„Ç©„Éº„Éû„ÉÉ„Éà"""
        from xml.etree.ElementTree import Element, SubElement, tostring
        from xml.dom import minidom
        
        # „É´„Éº„ÉàË¶ÅÁ¥†
        root = Element("analysis_result")
        root.set("file_path", result.file_path)
        root.set("language", result.language)
        
        # Èñ¢Êï∞
        if result.functions:
            functions_elem = SubElement(root, "functions")
            
            for func in result.functions:
                if self._should_include_item(func):
                    func_elem = SubElement(functions_elem, "function")
                    func_elem.set("name", func.name)
                    func_elem.set("visibility", func.visibility or "")
                    func_elem.set("start_line", str(func.start_line))
                    func_elem.set("end_line", str(func.end_line))
                    func_elem.set("is_method", str(func.is_method))
                    
                    if func.parameters:
                        params_elem = SubElement(func_elem, "parameters")
                        for param in func.parameters:
                            param_elem = SubElement(params_elem, "parameter")
                            param_elem.text = param
                    
                    if func.docstring:
                        doc_elem = SubElement(func_elem, "docstring")
                        doc_elem.text = func.docstring
        
        # „ÇØ„É©„Çπ
        if result.classes:
            classes_elem = SubElement(root, "classes")
            
            for cls in result.classes:
                if self._should_include_item(cls):
                    cls_elem = SubElement(classes_elem, "class")
                    cls_elem.set("name", cls.name)
                    cls_elem.set("visibility", cls.visibility or "")
                    cls_elem.set("start_line", str(cls.start_line))
                    cls_elem.set("end_line", str(cls.end_line))
                    
                    if cls.base_classes:
                        bases_elem = SubElement(cls_elem, "base_classes")
                        for base in cls.base_classes:
                            base_elem = SubElement(bases_elem, "base_class")
                            base_elem.text = base
        
        # XML„ÇíÊï¥ÂΩ¢
        rough_string = tostring(root, 'utf-8')
        reparsed = minidom.parseString(rough_string)
        return reparsed.toprettyxml(indent="  ")
    
    def _sort_items(self, items: List[Any]) -> List[Any]:
        """„Ç¢„Ç§„ÉÜ„É†„Çí„ÇΩ„Éº„Éà"""
        sort_by = self.options["sort_by"]
        
        if sort_by == "name":
            return sorted(items, key=lambda x: x.name.lower())
        elif sort_by == "line":
            return sorted(items, key=lambda x: x.start_line)
        elif sort_by == "type":
            return sorted(items, key=lambda x: type(x).__name__)
        else:
            return items
    
    def _should_include_item(self, item: Any) -> bool:
        """„Ç¢„Ç§„ÉÜ„É†„ÇíÂê´„ÇÅ„Çã„Åã„Å©„ÅÜ„Åã„ÇíÂà§ÂÆö"""
        filters = self.options["filter_by"]
        
        if not filters:
            return True
        
        # ÂèØË¶ñÊÄß„Éï„Ç£„É´„Çø
        if "visibility" in filters:
            if hasattr(item, 'visibility') and item.visibility not in filters["visibility"]:
                return False
        
        # ÂêçÂâç„Éï„Ç£„É´„Çø
        if "name_pattern" in filters:
            import re
            pattern = filters["name_pattern"]
            if not re.search(pattern, item.name):
                return False
        
        # Ë°åÁï™Âè∑„Éï„Ç£„É´„Çø
        if "line_range" in filters:
            start, end = filters["line_range"]
            if not (start <= item.start_line <= end):
                return False
        
        return True
    
    def _calculate_column_widths(self, items: List[Any], headers: List[str]) -> List[int]:
        """„ÉÜ„Éº„Éñ„É´„ÅÆ„Ç´„É©„É†ÂπÖ„ÇíË®àÁÆó"""
        widths = [len(h) for h in headers]
        
        for item in items:
            if hasattr(item, 'name'):
                widths[0] = max(widths[0], len(item.name))
            if hasattr(item, 'visibility'):
                widths[1] = max(widths[1], len(item.visibility or ""))
        
        return widths
    
    def _format_function_row(self, func: ModelFunction, col_widths: List[int]) -> str:
        """Èñ¢Êï∞„ÅÆ„ÉÜ„Éº„Éñ„É´Ë°å„Çí„Éï„Ç©„Éº„Éû„ÉÉ„Éà"""
        name = func.name.ljust(col_widths[0])
        visibility = (func.visibility or "").ljust(col_widths[1])
        params = (", ".join(func.parameters[:2]) + ("..." if len(func.parameters) > 2 else "")).ljust(col_widths[2])
        return_type = (func.return_type or "").ljust(col_widths[3])
        line_info = f"{func.start_line}-{func.end_line}".ljust(col_widths[4])
        
        row = f"{name} | {visibility} | {params} | {return_type} | {line_info}"
        
        if self.options["include_docstrings"] and len(col_widths) > 5:
            docstring = (func.docstring or "")[:50] + ("..." if len(func.docstring or "") > 50 else "")
            row += f" | {docstring.ljust(col_widths[5])}"
        
        return row
    
    def _format_class_summary(self, cls: ModelClass) -> str:
        """„ÇØ„É©„Çπ„ÅÆË¶ÅÁ¥Ñ„Çí„Éï„Ç©„Éº„Éû„ÉÉ„Éà"""
        base_info = f" extends {', '.join(cls.base_classes)}" if cls.base_classes else ""
        return f"üì¶ {cls.name}{base_info} ({cls.start_line}-{cls.end_line}) [{cls.visibility or 'default'}]"
    
    def _format_variable_summary(self, var: ModelVariable) -> str:
        """Â§âÊï∞„ÅÆË¶ÅÁ¥Ñ„Çí„Éï„Ç©„Éº„Éû„ÉÉ„Éà"""
        type_info = f": {var.type_annotation}" if var.type_annotation else ""
        return f"üìä {var.name}{type_info} ({var.start_line}) [{var.visibility or 'default'}]"
    
    def _format_import_summary(self, imp: ModelImport) -> str:
        """„Ç§„É≥„Éù„Éº„Éà„ÅÆË¶ÅÁ¥Ñ„Çí„Éï„Ç©„Éº„Éû„ÉÉ„Éà"""
        names = ", ".join(imp.names) if imp.names else "*"
        alias = f" as {imp.alias}" if imp.alias else ""
        return f"üì• from {imp.module} import {names}{alias}"
    
    def _function_to_dict(self, func: ModelFunction) -> Dict[str, Any]:
        """Èñ¢Êï∞„ÇíËæûÊõ∏„Å´Â§âÊèõ"""
        data = {
            "name": func.name,
            "start_line": func.start_line,
            "end_line": func.end_line,
            "is_method": func.is_method,
            "is_async": func.is_async
        }
        
        if self.options["include_visibility"]:
            data["visibility"] = func.visibility
        
        if func.parameters:
            data["parameters"] = func.parameters
        
        if func.return_type:
            data["return_type"] = func.return_type
        
        if self.options["include_docstrings"] and func.docstring:
            data["docstring"] = func.docstring
        
        if self.options["include_metadata"] and func.metadata:
            data["metadata"] = func.metadata
        
        return data
    
    def _class_to_dict(self, cls: ModelClass) -> Dict[str, Any]:
        """„ÇØ„É©„Çπ„ÇíËæûÊõ∏„Å´Â§âÊèõ"""
        data = {
            "name": cls.name,
            "start_line": cls.start_line,
            "end_line": cls.end_line,
            "is_abstract": cls.is_abstract
        }
        
        if self.options["include_visibility"]:
            data["visibility"] = cls.visibility
        
        if cls.base_classes:
            data["base_classes"] = cls.base_classes
        
        if cls.methods:
            data["methods"] = [self._function_to_dict(m) for m in cls.methods]
        
        if cls.fields:
            data["fields"] = cls.fields
        
        if self.options["include_docstrings"] and cls.docstring:
            data["docstring"] = cls.docstring
        
        if self.options["include_metadata"] and cls.metadata:
            data["metadata"] = cls.metadata
        
        return data
    
    def _variable_to_dict(self, var: ModelVariable) -> Dict[str, Any]:
        """Â§âÊï∞„ÇíËæûÊõ∏„Å´Â§âÊèõ"""
        data = {
            "name": var.name,
            "start_line": var.start_line,
            "end_line": var.end_line,
            "is_constant": var.is_constant
        }
        
        if self.options["include_visibility"]:
            data["visibility"] = var.visibility
        
        if var.type_annotation:
            data["type_annotation"] = var.type_annotation
        
        if var.default_value:
            data["default_value"] = var.default_value
        
        if self.options["include_metadata"] and var.metadata:
            data["metadata"] = var.metadata
        
        return data
    
    def _import_to_dict(self, imp: ModelImport) -> Dict[str, Any]:
        """„Ç§„É≥„Éù„Éº„Éà„ÇíËæûÊõ∏„Å´Â§âÊèõ"""
        data = {
            "module": imp.module,
            "start_line": imp.start_line,
            "end_line": imp.end_line,
            "is_wildcard": imp.is_wildcard
        }
        
        if imp.names:
            data["names"] = imp.names
        
        if imp.alias:
            data["alias"] = imp.alias
        
        if self.options["include_metadata"] and imp.metadata:
            data["metadata"] = imp.metadata
        
        return data
    
    def _format_function_markdown(self, func: ModelFunction) -> List[str]:
        """Èñ¢Êï∞„ÅÆMarkdownÂΩ¢Âºè"""
        lines = []
        
        # Èñ¢Êï∞„Ç∑„Ç∞„Éç„ÉÅ„É£
        visibility = f"`{func.visibility}` " if func.visibility else ""
        async_marker = "`async` " if func.is_async else ""
        method_marker = " *(method)*" if func.is_method else ""
        
        lines.append(f"### {visibility}{async_marker}`{func.name}`{method_marker}")
        
        # ‰ΩçÁΩÆÊÉÖÂ†±
        if self.options["include_line_numbers"]:
            lines.append(f"**‰ΩçÁΩÆ**: {func.start_line}-{func.end_line}Ë°å")
        
        # „Éë„É©„É°„Éº„Çø
        if func.parameters:
            lines.append(f"**„Éë„É©„É°„Éº„Çø**: `{', '.join(func.parameters)}`")
        
        # Êàª„ÇäÂÄ§
        if func.return_type:
            lines.append(f"**Êàª„ÇäÂÄ§**: `{func.return_type}`")
        
        # „Éâ„Ç≠„É•„É°„É≥„Éà
        if self.options["include_docstrings"] and func.docstring:
            lines.append(f"**Ë™¨Êòé**: {func.docstring}")
        
        return lines
    
    def _format_class_markdown(self, cls: ModelClass) -> List[str]:
        """„ÇØ„É©„Çπ„ÅÆMarkdownÂΩ¢Âºè"""
        lines = []
        
        # „ÇØ„É©„ÇπÂêç
        visibility = f"`{cls.visibility}` " if cls.visibility else ""
        abstract_marker = "`abstract` " if cls.is_abstract else ""
        
        lines.append(f"### {visibility}{abstract_marker}`{cls.name}`")
        
        # ‰ΩçÁΩÆÊÉÖÂ†±
        if self.options["include_line_numbers"]:
            lines.append(f"**‰ΩçÁΩÆ**: {cls.start_line}-{cls.end_line}Ë°å")
        
        # Á∂ôÊâø
        if cls.base_classes:
            lines.append(f"**Á∂ôÊâø**: `{', '.join(cls.base_classes)}`")
        
        # „É°„ÇΩ„ÉÉ„ÉâÊï∞
        if cls.methods:
            lines.append(f"**„É°„ÇΩ„ÉÉ„ÉâÊï∞**: {len(cls.methods)}")
        
        # „Éï„Ç£„Éº„É´„ÉâÊï∞
        if cls.fields:
            lines.append(f"**„Éï„Ç£„Éº„É´„ÉâÊï∞**: {len(cls.fields)}")
        
        # „Éâ„Ç≠„É•„É°„É≥„Éà
        if self.options["include_docstrings"] and cls.docstring:
            lines.append(f"**Ë™¨Êòé**: {cls.docstring}")
        
        return lines
    
    def _format_variable_markdown_row(self, var: ModelVariable) -> str:
        """Â§âÊï∞„ÅÆMarkdown„ÉÜ„Éº„Éñ„É´Ë°å"""
        name = f"`{var.name}`"
        type_info = f"`{var.type_annotation}`" if var.type_annotation else "‰∏çÊòé"
        visibility = var.visibility or "default"
        line_info = f"{var.start_line}"
        
        return f"| {name} | {type_info} | {visibility} | {line_info} |"
    
    def _format_function_html(self, func: ModelFunction) -> str:
        """Èñ¢Êï∞„ÅÆHTMLÂΩ¢Âºè"""
        visibility_class = f"visibility-{func.visibility}" if func.visibility else ""
        
        html = f'''
    <div class="function {visibility_class}">
        <div class="function-name">{func.name}</div>
        <div class="visibility">{func.visibility or 'default'}</div>
        <div class="line-number">Ë°å {func.start_line}-{func.end_line}</div>
        '''
        
        if func.parameters:
            html += f'<div class="parameters"><strong>„Éë„É©„É°„Éº„Çø:</strong> {", ".join(func.parameters)}</div>'
        
        if func.return_type:
            html += f'<div class="return-type"><strong>Êàª„ÇäÂÄ§:</strong> {func.return_type}</div>'
        
        if self.options["include_docstrings"] and func.docstring:
            html += f'<div class="docstring">{func.docstring}</div>'
        
        html += '</div>'
        
        return html
    
    def _format_class_html(self, cls: ModelClass) -> str:
        """„ÇØ„É©„Çπ„ÅÆHTMLÂΩ¢Âºè"""
        visibility_class = f"visibility-{cls.visibility}" if cls.visibility else ""
        
        html = f'''
    <div class="class {visibility_class}">
        <div class="class-name">{cls.name}</div>
        <div class="visibility">{cls.visibility or 'default'}</div>
        <div class="line-number">Ë°å {cls.start_line}-{cls.end_line}</div>
        '''
        
        if cls.base_classes:
            html += f'<div class="inheritance"><strong>Á∂ôÊâø:</strong> {", ".join(cls.base_classes)}</div>'
        
        if cls.methods:
            html += f'<div class="methods"><strong>„É°„ÇΩ„ÉÉ„ÉâÊï∞:</strong> {len(cls.methods)}</div>'
        
        if self.options["include_docstrings"] and cls.docstring:
            html += f'<div class="docstring">{cls.docstring}</div>'
        
        html += '</div>'
        
        return html
    
    def get_statistics(self) -> Dict[str, Any]:
        """„Éï„Ç©„Éº„Éû„ÉÉ„Çø„ÉºÁµ±Ë®à„ÇíÂèñÂæó"""
        return self.stats.copy()
    
    def reset_statistics(self):
        """Áµ±Ë®à„Çí„É™„Çª„ÉÉ„Éà"""
        self.stats = {
            "formatted_items": 0,
            "total_size": 0,
            "format_time": 0.0
        }


# ‰ΩøÁî®‰æã„Å®„ÉÜ„Çπ„Éà
if __name__ == "__main__":
    # „Çµ„É≥„Éó„É´„Éá„Éº„Çø„ÅÆ‰ΩúÊàê
    from tree_sitter_analyzer.models import AnalysisResult, ModelFunction, ModelClass
    
    # „Çµ„É≥„Éó„É´Èñ¢Êï∞
    sample_function = ModelFunction(
        name="calculate_sum",
        start_line=10,
        end_line=15,
        start_column=0,
        end_column=20,
        docstring="Êï∞ÂÄ§„ÅÆ„É™„Çπ„Éà„ÅÆÂêàË®à„ÇíË®àÁÆó„Åó„Åæ„Åô",
        parameters=["numbers: List[int]"],
        return_type="int",
        is_async=False,
        is_method=False,
        visibility="public",
        metadata={}
    )
    
    # „Çµ„É≥„Éó„É´„ÇØ„É©„Çπ
    sample_class = ModelClass(
        name="Calculator",
        start_line=20,
        end_line=40,
        start_column=0,
        end_column=10,
        docstring="Ë®àÁÆóÊ©ü„ÇØ„É©„Çπ",
        methods=[sample_function],
        fields=["value: int"],
        base_classes=[],
        is_abstract=False,
        visibility="public",
        metadata={}
    )
    
    # „Çµ„É≥„Éó„É´Ëß£ÊûêÁµêÊûú
    sample_result = AnalysisResult(
        file_path="sample.py",
        language="python",
        functions=[sample_function],
        classes=[sample_class],
        variables=[],
        imports=[],
        metadata={"parse_time": 0.1, "file_size": 1024}
    )
    
    # ÂêÑ„Éï„Ç©„Éº„Éû„ÉÉ„Éà„ÅÆ„ÉÜ„Çπ„Éà
    formats = ["table", "json", "csv", "markdown", "html"]
    
    for format_type in formats:
        print(f"\n{'='*50}")
        print(f"„Éï„Ç©„Éº„Éû„ÉÉ„Éà: {format_type}")
        print(f"{'='*50}")
        
        formatter = EnhancedFormatter(
            format_type,
            include_metadata=True,
            include_docstrings=True,
            include_line_numbers=True
        )
        
        try:
            output = formatter.format_analysis_result(sample_result)
            
            if format_type in ["json", "html", "xml"]:
                # Èï∑„ÅÑÂá∫Âäõ„ÅØÊúÄÂàù„ÅÆ500ÊñáÂ≠ó„ÅÆ„ÅøË°®Á§∫
                if len(output) > 500:
                    print(output[:500] + "\n... (truncated)")
                else:
                    print(output)
            else:
                print(output)
            
            # Áµ±Ë®àÊÉÖÂ†±
            stats = formatter.get_statistics()
            print(f"\nÁµ±Ë®à: {stats}")
            
        except Exception as e:
            print(f"„Ç®„É©„Éº: {str(e)}")
    
    print(f"\n{'='*50}")
    print("„Éï„Ç©„Éº„Éû„ÉÉ„Çø„Éº„ÉÜ„Çπ„ÉàÂÆå‰∫Ü")
    print(f"{'='*50}")