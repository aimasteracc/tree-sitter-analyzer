# 技術設計

## 背景

search_contentツールは現在、Shift_JISエンコードされたファイル内の日本語テキストを見つけることができませんが、extract_code_sectionは同じコンテンツを正常に読み取ります。この不整合は、ツール間の異なるエンコーディング処理アプローチに起因しています。

## 目標 / 非目標

### 目標
- **search_contentツールの自動エンコーディング検出**
- **全MCPツール間での一貫したエンコーディング処理**
- **既存APIへの破壊的変更ゼロ**
- **最小限のオーバーヘッドでのパフォーマンス最適化**
- **エンコーディングシナリオの包括的テストカバレッジ**

### 非目標
- 既存のencodingパラメータの動作変更
- 全ての可能なエンコーディングのサポート（一般的なもののみに焦点）
- ストリーミングコンテンツのリアルタイムエンコーディング検出
- ripgrepのコアエンコーディング処理の変更

## 決定事項

### 決定: 一貫性のためのEncodingManager使用
**根拠**: 既存の、テスト済みエンコーディング検出インフラストラクチャの活用
**検討した代替案**:
- カスタム検出ロジック → 却下（コード重複）
- サードパーティライブラリ → 却下（追加依存関係）

### 決定: ファイルサンプリングアプローチ（1KBヘッダー）
**根拠**: 精度とパフォーマンスのバランス
**検討した代替案**:
- 全ファイル読み込み → 却下（パフォーマンス影響）
- 最小サンプリング（256B） → 却下（精度の懸念）

### 決定: 検出失敗時のUTF-8フォールバック
**根拠**: 最も一般的なエンコーディング、後方互換性の維持
**検討した代替案**:
- エラーで失敗 → 却下（ユーザーワークフローの中断）
- 複数エンコーディングの試行 → 却下（パフォーマンス影響）

### 決定: エンコーディング検出結果のキャッシュ
**根拠**: 同じファイルの重複検出を回避
**実装**: 既存の検索キャッシュシステムとの統合

## アーキテクチャ

```
search_content_tool.py
├── execute()
│   ├── validate_arguments()
│   ├── _detect_encoding_if_needed()  # 新規
│   │   ├── EncodingManager.detect_encoding()
│   │   ├── キャッシュ検索/保存
│   │   └── UTF-8へのフォールバック
│   ├── build_rg_command()
│   └── run_command_capture()
```

### 主要コンポーネント

#### 1. エンコーディング検出関数
```python
async def _detect_encoding_if_needed(
    self, 
    files: list[str], 
    user_encoding: str | None
) -> str | None:
    """明示的に提供されていない場合、ファイルのエンコーディングを検出する。"""
```

#### 2. 統合ポイント
- **EncodingManager**: 既存の検出ロジックの再利用
- **Search Cache**: キャッシュキーと共に検出結果を保存
- **fd_rg_utils**: 検出されたエンコーディングをripgrepコマンドに渡す

#### 3. エラーハンドリング戦略
```
検出成功 → 検出されたエンコーディングを使用
検出失敗 → 警告ログ + UTF-8を使用
ユーザー指定 → 検出をスキップ、ユーザー値を使用
```

## リスク / トレードオフ

### リスク: ファイルサンプリングによるパフォーマンス影響
**軽減策**: 
- サンプリングを1KBに制限
- 結果を積極的にキャッシュ
- 明示的に指定されたエンコーディングの検出をスキップ

### リスク: エッジケースでの検出精度
**軽減策**:
- 様々なエンコーディングでの包括的テストスイート
- フォールバック戦略で機能性を保証
- ユーザーは明示的エンコーディングで上書き可能

### リスク: キャッシュ無効化の複雑さ
**軽減策**:
- 既存のキャッシュシステムとの統合
- 無効化にファイル変更時刻を使用
- エンコーディング検出エラー時のキャッシュクリア

## 移行計画

### フェーズ1: コア実装
1. エンコーディング検出関数の追加
2. search_content executeメソッドとの統合
3. 自動検出エンコーディング用のfd_rg_utils更新

### フェーズ2: テストと検証
1. 包括的テストスイートの作成
2. 実世界ファイルでの検証
3. パフォーマンスベンチマーク

### フェーズ3: ドキュメントとロールアウト
1. ツールドキュメントの更新
2. デバッグログの追加
3. 問題の監視

### ロールバック計画
- 自動検出用の機能フラグ（必要に応じて）
- 元の動作への復帰で全機能を保持
- データ移行不要

## 未解決の質問

- **質問**: 全ファイルのエンコーディングを検出すべきか、検索失敗時のみか？
- **回答**: 二重実行オーバーヘッドを避けるため積極的に検出

- **質問**: 混合エンコーディングファイルセットの処理方法は？
- **回答**: ファイル毎に検出、最も一般的なエンコーディングをフォールバックとして使用

- **質問**: 検出結果をセッション間で永続化すべきか？
- **回答**: 既存のキャッシュTTLを使用、永続ストレージ不要

## 実装詳細

### ファイルサンプリング戦略
```python
def _sample_file_for_encoding(file_path: str) -> bytes:
    """エンコーディング検出のためファイルの最初の1KBを読み取る。"""
    with open(file_path, 'rb') as f:
        return f.read(1024)
```

### キャッシュ統合
```python
def _get_encoding_cache_key(file_path: str) -> str:
    """ファイルmtimeを含むキャッシュキーを生成する。"""
    stat = os.stat(file_path)
    return f"encoding:{file_path}:{stat.st_mtime}"
```

### ログ戦略
```python
logger.debug(f"'{file_path}' のエンコーディングを '{encoding}' として自動検出しました")
logger.debug(f"エンコーディング '{encoding}' をripgrepコマンドに適用しました")
logger.warning(f"'{file_path}' のエンコーディング検出に失敗しました。UTF-8を使用します")
