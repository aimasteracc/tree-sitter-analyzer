# Plugin Base Class Extraction - Requirements

## 現状分析（Current State Analysis）

### コード重複の実態

Tree-sitter Analyzerプロジェクトは17種類のプログラミング言語をサポートしており、各言語に対応するプラグインが`tree_sitter_analyzer/languages/`ディレクトリに存在する。

**重複メソッドの分布:**

| メソッド名 | 重複数 | 影響ファイル | 推定行数 |
|-----------|--------|------------|----------|
| `_reset_caches()` | 14/17 | 全プラグイン | ~10行/ファイル |
| `_get_node_text_optimized()` | 10/17 | 主要プラグイン | ~50-100行/ファイル |
| `_traverse_and_extract_iterative()` | 6/17 | Java系言語 | ~150-200行/ファイル |
| `_extract_*_optimized()` | 14/17 | 全プラグイン | ~30-50行/メソッド |
| キャッシュ初期化 | 14/17 | 全プラグイン | ~20行/ファイル |

**重複ファイル一覧:**
```
tree_sitter_analyzer/languages/
├── c_plugin.py           (1,100+ lines) - 重複: 高
├── cpp_plugin.py         (1,347 lines)  - 重複: 高
├── csharp_plugin.py      (1,077 lines)  - 重複: 高
├── go_plugin.py          (950+ lines)   - 重複: 中
├── java_plugin.py        (1,292 lines)  - 重複: 高
├── javascript_plugin.py  (1,619 lines)  - 重複: 高
├── kotlin_plugin.py      (900+ lines)   - 重複: 中
├── markdown_plugin.py    (600+ lines)   - 重複: 中
├── php_plugin.py         (1,100+ lines) - 重複: 高
├── python_plugin.py      (1,640 lines)  - 重複: 高
├── ruby_plugin.py        (1,000+ lines) - 重複: 中
├── rust_plugin.py        (1,000+ lines) - 重複: 中
├── sql_plugin.py         (700+ lines)   - 重複: 低
├── typescript_plugin.py  (1,500+ lines) - 重複: 高
├── css_plugin.py         (800+ lines)   - 重複: 低
├── html_plugin.py        (900+ lines)   - 重複: 低
└── yaml_plugin.py        (500+ lines)   - 重複: 低
```

**推定重複コード量:**
- 合計: **約2,000-2,500行**の重複コード
- 保守コスト: バグ修正を14回繰り返す必要がある
- テストコスト: 同じロジックに対して複数のテストが必要

### 現在のアーキテクチャ

**プラグインベースクラス（plugins/base.py）:**
- `ElementExtractor` (ABC) - 抽象基底クラス
  - 抽象メソッド: `extract_functions()`, `extract_classes()`, `extract_variables()`, `extract_imports()`, `extract_constants()`
  - **問題点**: 実装の共通ロジックが提供されていない（インターフェースのみ）

**各言語プラグインの実装パターン:**
```python
class JavaPlugin(ElementExtractor):
    def __init__(self):
        super().__init__()
        # ❌ 各プラグインで重複
        self._node_text_cache: dict[int, str] = {}
        self._processed_nodes: set[int] = set()
        self._element_cache: dict[tuple[int, str], Any] = {}
        self._annotation_cache: dict[int, list[str]] = {}
        self._signature_cache: dict[int, str] = {}
        # ... more caches

    # ❌ 各プラグインで重複
    def _reset_caches(self):
        self._node_text_cache.clear()
        self._processed_nodes.clear()
        # ...

    # ❌ 各プラグインで重複（100行以上）
    def _get_node_text_optimized(self, node):
        cache_key = id(node)
        if cache_key in self._node_text_cache:
            return self._node_text_cache[cache_key]
        # ... 複雑なテキスト抽出ロジック

    # ❌ 各プラグインで重複（200行以上）
    def _traverse_and_extract_iterative(self, root_node, extractors, results, element_type):
        # ... 複雑な反復的トラバーサルロジック
```

### 問題識別（Problem Identification）

**1. 保守性の問題**
- バグ修正時に14ファイルを修正する必要がある
- 修正漏れのリスクが高い
- 実際に過去のコミット履歴で同じ修正が複数ファイルに適用されている

**2. 一貫性の問題**
- プラグイン間で微妙に異なる実装が存在する
- 一部のプラグインは最適化が適用されているが、他は未適用
- エラーハンドリングの実装が統一されていない

**3. テスト効率の問題**
- 同じロジックを複数回テストする必要がある
- テストカバレッジが実質的に重複している
- プラグイン追加時にテストコードも重複して書く必要がある

**4. 学習コストの問題**
- 新しいコントリビューターが各プラグインの実装を理解する必要がある
- 共通パターンが明示的に文書化されていない
- コードレビュー時に重複コードの確認が困難

**5. パフォーマンスの問題**
- 各プラグインインスタンスが独自のキャッシュを持つ
- メモリ使用量が非効率
- キャッシュ戦略の改善が14ファイルに適用が必要

## 目標定義（Goals & Objectives）

### 主目標

**1. コード重複の削減**
- ✅ 2,000行以上の重複コードを削除
- ✅ 共通ロジックを`BaseElementExtractor`クラスに集約
- ✅ 言語固有のロジックのみを各プラグインに残す

**2. 保守性の向上**
- ✅ バグ修正を1箇所で行えるようにする
- ✅ 新機能追加を1箇所で行えるようにする
- ✅ 一貫性のあるエラーハンドリング

**3. 拡張性の向上**
- ✅ 新しい言語プラグインの追加が容易になる
- ✅ プラグインのテンプレート化
- ✅ プラグイン開発ドキュメントの整備

**4. テスト効率の向上**
- ✅ 共通ロジックのテストを1回で済ませる
- ✅ プラグイン固有のテストに集中できる
- ✅ テストカバレッジの実質的向上

### 非目標（Non-Goals）

- ❌ プラグインAPIの破壊的変更（既存の公開APIは維持）
- ❌ パフォーマンスの大幅な改善（リファクタリングが主目的）
- ❌ 新機能の追加（既存機能の整理のみ）
- ❌ 全プラグインの完全な統一（言語固有のロジックは維持）

## 非機能性要求（Non-functional Requirements）

### 後方互換性
- ✅ 既存のテストスイート（8,405テスト）が全て通過すること
- ✅ 公開APIの変更なし（内部実装のみリファクタリング）
- ✅ MCP toolsの動作に影響なし
- ✅ CLIコマンドの動作に影響なし

### パフォーマンス
- ✅ パフォーマンスベンチマークが劣化しないこと
- ✅ 既存のキャッシュ戦略を維持すること
- ✅ メモリ使用量が増加しないこと

### コード品質
- ✅ 型ヒントの完全性（100% mypy準拠）
- ✅ テストカバレッジ80%以上を維持
- ✅ Ruffリンティング準拠
- ✅ ドキュメント文字列の完備

### 開発者体験
- ✅ 新しいプラグイン追加ガイドの作成
- ✅ マイグレーションガイドの作成（既存プラグイン改修者向け）
- ✅ アーキテクチャ図の更新

## 用例場景（Use Cases）

### UC1: バグ修正が必要な場合
**現状:**
```
1. _get_node_text_optimized()にバグ発見
2. 10個のプラグインファイルを修正
3. 10個のテストファイルを修正
4. 修正漏れのリスク
```

**目標:**
```
1. BaseElementExtractor._get_node_text_optimized()を修正
2. 1つのテストファイルを修正
3. 全プラグインに自動的に適用
```

### UC2: 新しい言語プラグインを追加する場合
**現状:**
```
1. 既存プラグイン（例: JavaPlugin）をコピー
2. 1,000行以上のコードから言語固有の部分を探す
3. Tree-sitterクエリを書き換える
4. 重複コードも含めてテストを書く
```

**目標:**
```
1. BaseElementExtractorを継承
2. 言語固有のTree-sitterクエリのみ定義（50-100行）
3. 言語固有の抽出ロジックのみ実装（100-200行）
4. 言語固有のテストのみ書く
```

### UC3: キャッシュ戦略を改善する場合
**現状:**
```
1. 新しいキャッシュアルゴリズムを設計
2. 14個のプラグインに適用
3. 一部のプラグインで実装が異なる
4. パフォーマンステストを14回実施
```

**目標:**
```
1. BaseElementExtractorのキャッシュロジックを改善
2. 全プラグインに自動的に適用
3. 一貫した実装
4. パフォーマンステストを1回実施
```

## 術語表（Glossary）

- **ElementExtractor**: 現在の抽象基底クラス（インターフェース定義のみ）
- **BaseElementExtractor**: 新しく作成する具象基底クラス（共通実装を含む）
- **LanguagePlugin**: 各言語の解析ロジックを実装するプラグインクラス
- **Tree-sitter**: 使用している構文解析ライブラリ
- **Iterative traversal**: 再帰を避けた反復的なASTトラバーサル
- **Node text extraction**: ASTノードから元のソースコードテキストを抽出
- **Element cache**: 抽出した要素（関数、クラスなど）のキャッシュ
- **Query**: Tree-sitterのS式クエリ言語で記述されたパターン

## 制約条件（Constraints）

### 技術的制約
- ✅ Python 3.10+対応
- ✅ Tree-sitterライブラリのAPI制約に従う
- ✅ 既存のAnalysisEngineとの統合を維持
- ✅ Windowsパス処理の互換性維持

### プロジェクト制約
- ✅ 段階的な移行（全プラグインを一度に変更しない）
- ✅ 各段階でテストが通過すること
- ✅ 破壊的変更を避ける
- ✅ ドキュメントの同時更新

### リソース制約
- ✅ 推定作業期間: 3-5日
- ✅ 既存機能を壊さないことが最優先
- ✅ パフォーマンス劣化を許容しない

## 成功基準（Success Criteria）

### 定量的基準
- ✅ 重複コード行数が2,000行以上削減される
- ✅ 全テスト（8,405個）が通過
- ✅ テストカバレッジが80%以上維持される
- ✅ mypy型チェックが100%通過
- ✅ パフォーマンスベンチマークが劣化しない（±5%以内）

### 定性的基準
- ✅ 新しいプラグイン追加が既存の1/3以下の工数で可能
- ✅ コードレビュー時の理解しやすさが向上
- ✅ ドキュメントが整備され、新規コントリビューターが理解しやすい
- ✅ 技術的負債が削減される

## リスク分析（Risk Analysis）

### 高リスク
- **リスク**: テストが壊れる可能性
  - **対策**: 段階的な移行、各段階でのテスト実行
  - **緩和策**: Golden Masterテストによる回帰検出

- **リスク**: パフォーマンス劣化
  - **対策**: ベンチマーク実行、プロファイリング
  - **緩和策**: 問題があれば元に戻せる設計

### 中リスク
- **リスク**: プラグイン間の実装差異による統合困難
  - **対策**: 共通パターンの詳細な分析
  - **緩和策**: プラグイン毎にオプトイン可能な設計

- **リスク**: 予期しない依存関係の発見
  - **対策**: 依存関係グラフの事前分析
  - **緩和策**: 必要に応じて設計を調整

### 低リスク
- **リスク**: ドキュメント更新漏れ
  - **対策**: チェックリスト作成
  - **緩和策**: レビュープロセスで確認

## 優先順位（Priorities）

### P0（必須）
1. BaseElementExtractorクラスの作成
2. キャッシュ管理メソッドの統合
3. ノードテキスト抽出の統合
4. 既存テストの通過

### P1（重要）
2. 反復的トラバーサルの統合
3. 最適化された抽出メソッドの統合
4. 新しいプラグイン追加ガイドの作成

### P2（できれば）
1. パフォーマンス最適化
2. エラーハンドリングの統一
3. 完全なアーキテクチャ図の作成

## 次のステップ

このrequirements.mdが承認されたら、以下のファイルを作成する：

1. **design.md** - BaseElementExtractorの詳細設計
   - クラス図
   - メソッド一覧
   - 統合戦略
   - マイグレーションパス

2. **tasks.md** - 実装タスクの詳細な分解
   - フェーズ分割
   - 各タスクの依存関係
   - 検証基準

3. **progress.md** - 実施ログと問題追跡
